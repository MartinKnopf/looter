// Generated by CoffeeScript 1.8.0
(function() {
  var clickStartGame, randomize, resetUi, sinPrice, stocks;

  stocks = [
    {
      min: 900,
      max: 3500
    }
  ];

  sinPrice = function(min, max, x) {
    return Math.floor((Math.sin(x) + 1.4) * (max + 1 - min) + min);
  };

  randomize = function(min, max, price) {
    return Math.floor(_.random(price - _.random(min, max) / 2, price + _.random(min, max) / 2));
  };

  resetUi = function() {
    $('.turn-nr').text('');
    $('.stock1 .price').text('');
    $('.max-possible-balance-container').hide();
    return $('.score-container').hide();
  };

  resetUi();

  clickStartGame = Rx.Observable.fromEvent($('.start-new-game'), 'click');

  clickStartGame.subscribe(function() {
    var balance, canBuy, canSell, cannotBuy, cannotSell, clickBuy, clickNextTurn, clickSell, lastTurn, lowestPrice, maxPossibleBalance, newBuy, newPrice, newSell, newStockAmount, newTurn, score;
    resetUi();
    $('.end-turn').prop('disabled', false);
    clickNextTurn = Rx.Observable.fromEvent($('.end-turn'), 'click');
    clickBuy = Rx.Observable.fromEvent($('.stock1 .buy'), 'click');
    clickSell = Rx.Observable.fromEvent($('.stock1 .sell'), 'click');
    newTurn = clickNextTurn.startWith(1).select(function(event, idx) {
      return idx + 1;
    }).take(11);
    lastTurn = newTurn.filter(function(x) {
      return x > 10;
    });
    newPrice = newTurn.map(_.partial(sinPrice, stocks[0].min, stocks[0].max)).map(_.partial(randomize, stocks[0].min, stocks[0].max)).takeUntil(lastTurn).publish();
    lowestPrice = newPrice.scan(10000, function(acc, price) {
      if (acc <= price) {
        return acc;
      } else {
        return price;
      }
    });
    newBuy = Rx.Observable.combineLatest(clickBuy, newPrice, function(event, price) {
      return {
        event: event,
        price: price
      };
    }).distinctUntilChanged(function(x) {
      return x.event;
    }).map(function(x) {
      return -x.price;
    }).takeUntil(lastTurn);
    newSell = Rx.Observable.combineLatest(clickSell, newPrice, function(event, price) {
      return {
        event: event,
        price: price
      };
    }).distinctUntilChanged(function(x) {
      return x.event;
    }).map(function(x) {
      return x.price;
    }).takeUntil(lastTurn);
    newStockAmount = newBuy.map(function() {
      return 1;
    }).merge(newSell.map(function() {
      return -1;
    })).scan(0, function(acc, x) {
      return acc + x;
    }).startWith(0).takeUntil(lastTurn);
    balance = Rx.Observable.merge(newBuy, newSell).startWith(10000).scan(function(sum, price) {
      return sum + price;
    }).takeUntil(lastTurn);
    canBuy = Rx.Observable.combineLatest(balance, newPrice, function(balance, price) {
      return {
        balance: balance,
        price: price
      };
    }).filter(function(x) {
      return x.balance >= x.price;
    }).takeUntil(lastTurn);
    cannotBuy = Rx.Observable.combineLatest(balance, newPrice, function(balance, price) {
      return {
        balance: balance,
        price: price
      };
    }).filter(function(x) {
      return x.balance < x.price;
    }).merge(lastTurn).startWith(true);
    canSell = newStockAmount.filter(function(amount) {
      return amount > 0;
    }).takeUntil(lastTurn);
    cannotSell = newStockAmount.filter(function(amount) {
      return amount <= 0;
    }).merge(lastTurn).startWith(true);
    maxPossibleBalance = lastTurn.merge(balance.last().combineLatest(newPrice.min(), newPrice.max(), function(balance, minPrice, maxPrice) {
      return Math.floor(10000 / minPrice) * maxPrice;
    }));
    score = maxPossibleBalance.combineLatest(balance.last(), function(max, actual) {
      return Math.round(actual / max * 10000) / 100;
    });
    newTurn.subscribe(function(turn) {
      return $('.turn-nr').text(turn);
    });
    lastTurn.subscribe(function() {
      $('.turn-nr').text('game over');
      return $('.end-turn').prop('disabled', true);
    });
    newPrice.subscribe(function(price) {
      return $('.stock1 .price').text(price);
    });
    balance.subscribe(function(balance) {
      return $('.balance').text(balance);
    });
    canBuy.subscribe(function() {
      return $('.stock1 .buy').prop('disabled', false);
    });
    cannotBuy.subscribe(function() {
      return $('.stock1 .buy').prop('disabled', true);
    });
    canSell.subscribe(function() {
      return $('.stock1 .sell').prop('disabled', false);
    });
    cannotSell.subscribe(function() {
      return $('.stock1 .sell').prop('disabled', true);
    });
    newBuy.subscribe(function() {
      return $('.stock1 .sell').prop('disabled', false);
    });
    newStockAmount.subscribe(function(amount) {
      return $('.stock1 .amount').text(amount);
    });
    maxPossibleBalance.subscribe(function(maxPossibleBalance) {
      $('.max-possible-balance-container').show();
      return $('.max-possible-balance').text(maxPossibleBalance);
    });
    score.subscribe(function(score) {
      $('.score-container').show();
      return $('.score').text(score + ' %');
    });
    return newPrice.connect();
  });

}).call(this);
