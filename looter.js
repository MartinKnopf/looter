// Generated by CoffeeScript 1.8.0
(function() {
  var clickStartGame, initApp, randomize, sinPrice, stocks;

  stocks = [
    {
      min: 900,
      max: 3500
    }
  ];

  sinPrice = function(min, max, x) {
    return Math.floor((Math.sin(x) + 1.4) * (max + 1 - min) + min);
  };

  randomize = function(min, max, price) {
    return Math.floor(_.random(price - _.random(min, max) / 2, price + _.random(min, max) / 2));
  };

  initApp = Rx.Observable["return"](true);

  clickStartGame = Rx.Observable.fromEvent($('.start-new-game'), 'click');

  clickStartGame.subscribe(function() {
    var balance, canBuy, canSell, cannotBuy, cannotSell, clickBuy, clickNextTurn, clickSell, gameOver, lastTurn, newBuy, newPrice, newSell, newStockAmount, newTurn, profit, progressBar, resettableTimer;
    $('.end-turn').prop('disabled', false);
    clickNextTurn = Rx.Observable.fromEvent($('.end-turn'), 'click');
    clickBuy = Rx.Observable.fromEvent($('.stock1 .buy'), 'click');
    clickSell = Rx.Observable.fromEvent($('.stock1 .sell'), 'click');
    resettableTimer = clickNextTurn.merge(Rx.Observable.interval(3000).takeUntil(clickNextTurn).merge(clickNextTurn.flatMap(function() {
      return Rx.Observable.interval(3000).takeUntil(clickNextTurn);
    }))).takeUntil(clickStartGame);
    newTurn = resettableTimer.startWith(1).select(function(event, idx) {
      return idx + 1;
    }).take(11);
    lastTurn = newTurn.filter(function(turn) {
      return turn > 10;
    }).combineLatest(clickNextTurn, function(turn, event) {
      return turn;
    }).takeUntil(clickStartGame);
    newPrice = newTurn.map(_.partial(sinPrice, stocks[0].min, stocks[0].max)).map(_.partial(randomize, stocks[0].min, stocks[0].max)).takeUntil(lastTurn).publish();
    newBuy = Rx.Observable.combineLatest(clickBuy, newPrice, function(event, price) {
      return {
        event: event,
        price: price
      };
    }).distinctUntilChanged(function(x) {
      return x.event;
    }).map(function(x) {
      return -x.price;
    }).takeUntil(lastTurn);
    newSell = Rx.Observable.combineLatest(clickSell, newPrice, function(event, price) {
      return {
        event: event,
        price: price
      };
    }).distinctUntilChanged(function(x) {
      return x.event;
    }).map(function(x) {
      return x.price;
    }).takeUntil(lastTurn);
    newStockAmount = newBuy.map(function() {
      return 1;
    }).merge(newSell.map(function() {
      return -1;
    })).scan(0, function(acc, x) {
      return acc + x;
    }).startWith(0).takeUntil(lastTurn);
    balance = Rx.Observable.merge(newBuy, newSell).startWith(10000).scan(function(sum, price) {
      return sum + price;
    }).takeUntil(lastTurn);
    canBuy = Rx.Observable.combineLatest(balance, newPrice, function(balance, price) {
      return {
        balance: balance,
        price: price
      };
    }).filter(function(x) {
      return x.balance >= x.price;
    }).takeUntil(lastTurn);
    cannotBuy = Rx.Observable.combineLatest(balance, newPrice, function(balance, price) {
      return {
        balance: balance,
        price: price
      };
    }).filter(function(x) {
      return x.balance < x.price;
    }).merge(lastTurn).startWith(true);
    canSell = newStockAmount.filter(function(amount) {
      return amount > 0;
    }).takeUntil(lastTurn);
    cannotSell = newStockAmount.filter(function(amount) {
      return amount <= 0;
    }).merge(lastTurn).startWith(true);
    progressBar = newTurn.flatMap(function() {
      return Rx.Observable.timer(0, 1000).take(3);
    }).map(function(x) {
      return 3 - x;
    }).startWith(3).takeUntil(lastTurn);
    profit = balance.last().map(function(x) {
      return Math.round((x - 10000) / 10000 * 100 * 100) / 100;
    }).map(function(x) {
      return x + ' %';
    });
    gameOver = lastTurn.map(function() {
      return 'game over';
    });
    szep.ctrl('game', {
      initApp: initApp,
      clickStartGame: clickStartGame,
      newPrice: newPrice,
      newStockAmount: newStockAmount,
      canBuy: canBuy,
      newBuy: newBuy,
      cannotBuy: cannotBuy,
      canSell: canSell,
      cannotSell: cannotSell,
      newTurn: newTurn,
      balance: balance,
      progressBar: progressBar,
      lastTurn: lastTurn,
      gameOver: gameOver,
      profit: profit
    });
    return newPrice.connect();
  });

}).call(this);
